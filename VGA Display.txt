@ === 1. DE1-SoC VGA Base Addresses and Constants ===

    .equ PIXEL_BUFFER_BASE, 0xC8000000 @ ARM HPS Pixel Buffer Address
    .equ CHAR_BUFFER_BASE,  0xC9000000 @ ARM HPS Character Buffer Address

    .equ PIXEL_WIDTH,       320        @ Screen resolution width
    .equ PIXEL_HEIGHT,      240        @ Screen resolution height
    .equ MEMORY_PITCH,      1024       @ Bytes per row for pixel buffer

    @ 16-bit R5G6B5 Color Values
    .equ BRIGHT_BLUE,       0x001F     @ 0b00000 000000 11111
    .equ BRIGHT_RED,        0xF800     @ 0b11111 000000 00000


    @ === 2. Program Entry Point ===
    .global _start
_start:
    @ R4 will hold the Pixel Buffer Base Address (0xC8000000)
    LDR R4, =PIXEL_BUFFER_BASE
    
    @ R9 will hold the Character Buffer Base Address (0xC9000000)
    LDR R9, =CHAR_BUFFER_BASE

    @ --- Part 1: Clear Screen to Blue ---
    @ R5 = BRIGHT_BLUE color for clearing
    MOV R5, #BRIGHT_BLUE
    
    MOV R1, #0  @ R1 = Current Y (0 to 239)
Y_Clear_Loop:
    CMP R1, #PIXEL_HEIGHT
    BGE Draw_Square
    
    LSL R6, R1, #10 @ R6 = Y * 1024 (Y Offset)
    
    MOV R0, #0  @ R0 = Current X (0 to 319)
X_Clear_Loop:
        CMP R0, #PIXEL_WIDTH
        BGE next_clear_y

        LSL R7, R0, #1      @ R7 = X * 2 (X Offset)
        ADD R3, R6, R7      @ R3 = Total Offset
        ADD R8, R4, R3      @ R8 = Final Pixel Address
        
        STRH R5, [R8]       @ Store Blue
        
        ADD R0, R0, #1
        B X_Clear_Loop
        
next_clear_y:
    ADD R1, R1, #1
    B Y_Clear_Loop


    @ --- Part 2: Draw a Red Square in the Center ---
Draw_Square:
    @ R5 = BRIGHT_RED color
    MOV R5, #BRIGHT_RED
    
    @ Start (140, 110) to End (180, 130)
    MOV R1, #110    @ R1 = Y Start
Y_Square_Loop:
    CMP R1, #130    @ Check Y End
    BGT Display_Text
    
    LSL R6, R1, #10 @ R6 = Y * 1024 (Y Offset)
    
    MOV R0, #140    @ R0 = X Start
X_Square_Loop:
        CMP R0, #180    @ Check X End
        BGT next_square_y

        LSL R7, R0, #1      @ R7 = X * 2 (X Offset)
        ADD R3, R6, R7      @ R3 = Total Offset
        ADD R8, R4, R3      @ R8 = Final Pixel Address
        
        STRH R5, [R8]       @ Store Red
        
        ADD R0, R0, #1
        B X_Square_Loop
        
next_square_y:
    ADD R1, R1, #1
    B Y_Square_Loop


    @ --- Part 3: Display "HELLO ARM" Text ---
Display_Text:
    @ Character Grid: 80 columns x 60 rows
    @ Text will start at X=37 (center) and Y=40 (below the square)
    
    @ R1 = Y-coordinate (row 40)
    MOV R1, #40
    
    @ R0 = X-coordinate (column 37)
    MOV R0, #37
    
    @ R2 = Address of the string to be displayed
    LDR R2, =message
    
Text_Loop:
    LDRB R5, [R2], #1   @ Load 1 byte (ASCII char) from R2 into R5, then increment R2
    CMP R5, #0          @ Check for null terminator (end of string)
    BEQ stop_program
    
    @ Calculate Character Offset: (Y * 128) + X
    LSL R6, R1, #7      @ R6 = Y * 128 (128 = 2^7)
    ADD R3, R6, R0      @ R3 = (Y Offset) + X
    
    @ Calculate Final Character Address: (Base + Offset)
    ADD R8, R9, R3      @ R8 = 0xC9000000 + R3
    
    @ Write the Character
    STRB R5, [R8]       @ STRB (Store Byte) writes 8-bit ASCII char (R5) to address (R8)
    
    @ Increment X for the next character
    ADD R0, R0, #1
    B Text_Loop

    
    @ === 4. Program End and Data Section ===
stop_program:
    B stop_program              @ Infinite loop to halt execution

.data
message:
    .asciz "HELLO ARM"         @ ASCII string with null terminator
